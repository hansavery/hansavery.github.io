<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>HansAvery.com</title>
</head>
<body>
    <h1 id="header">Hans Avery</h1>

    <div id="tblcontainer">
        <table id="tbl"></table>
    </div>
</body>
<style>
    body {margin: 0; overflow: hidden;}
    h1 {font-family: sans-serif;}
    h1 div {display: inline; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;}


    #tblcontainer {position: relative; overflow: scroll; height: 80vh; width: 100%;}
    table {position: relative; border-collapse: collapse; border: 0.5px solid black; font-family: sans-serif; white-space: nowrap; line-height: 1.4em;} /* line height less than row height below but similar (or at least bigger than 1em?) to ensure text is centered correctly */
    td {text-align: center; padding: 0; min-width: 2.5em;}
    th {text-align: center; padding: 0;}
    .goal {background-color: lightblue;}


    .cell {border: 0.5px solid gray;}
    .rowLabel {
        background-color: lightgray;
        border-color: black;
        border-style: solid;
        border-width: 0.5px 1px;
    }
    .colLabel {
        background-color: lightgray;
        border-color: black;
        border-style: solid;
        border-width: 1px 0.5px;
    }
    .corner {
        background-color: lightgray;
        border-color: black; 
        border-style: solid; 
        border-width: 1px;
    }

    thead th {
        position: -webkit-sticky; /* for Safari */
        position: sticky;
        top: 0;
    }

    th.corner {
        left: 0;
        z-index: 1;
    }

    tbody th {
        position: -webkit-sticky; /* for Safari */
        position: sticky;
        left: 0;
    }


    td.selected {outline: .3em solid green; outline-offset: -.15em;}
    .rowLabel.selected {background-color: darkgray;}
    .colLabel.selected {background-color: darkgray;}


    /* div {
  max-width: 40em;
  max-height: 20em;
  overflow: scroll;
  position: relative;
}

thead th {
  position: -webkit-sticky;
  position: sticky;
  top: 0;
  background: #000;
  color: #FFF;
}

thead th:first-child {
  left: 0;
  z-index: 1;
}

tbody th {
  position: -webkit-sticky;
  position: sticky;
  left: 0;
  background: #FFF;
  border-right: 1px solid #CCC;
} */



</style>
<script src="./levels.js"></script>
<script>


//-- state

function Game() {
    this.sheet = new Sheet();
    this.sheet.loadLevel(LEVELS[0]);
    this.sheet.selectXY(0, 0);

    const tblcontainer = document.getElementById('tblcontainer');
    this.view = new View(this.sheet, tblcontainer);
    this.view.makeGrid();
    this.view.paint();

    tbl.onclick = this.createClickHandler();
    window.addEventListener('keydown', this.createKeyHandler(), false);
};


Game.prototype.createClickHandler = function() {
    self = this;
    return function (event) {
        if (!event.target || event.target.nodeName !== 'TD')
            return;
        if (event.shift) {
            alert('not implemented yet')    
        }
        else {
            if (event.target.classList.contains('rowLabel'))
                selectRow(event.target);
            else if (event.target.classList.contains('colLabel'))
                selectCol(event.target);
            else
                target = self.view.translateTarget(event.target);
                self.sheet.selectXY(target.x, target.y);
                self.view.paint();
        }
    };
};


Game.prototype.createKeyHandler = function() {
    self = this;
    directions = ['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown']
    return function keyHandler(event) {
        event = event || window.event;
        let key = event.key;
        if (directions.indexOf(key) !== -1) {
            let moveType = event.ctrlKey ? 'skip' : 'step';
            self.sheet.moveSelection(key, moveType);
            event.preventDefault();
            event.stopPropagation();
        }
        else if (key === 'Delete') {
            self.sheet.updateSelectedCellValue('');
            self.view.updateCellValue('');
            event.preventDefault();
            event.stopPropagation();
        }
        else if (key.length === 1 && !event.ctrlKey &&
                 (  ('a' <= key && key <= 'z') ||
                    ('A' <= key && key <= 'Z') ||
                    ('0' <= key && key <= '9'))){
            self.sheet.updateSelectedCellValue(key);
            self.view.updateCellValue(key);
            event.preventDefault();
            event.stopPropagation();
        }
        self.view.paint();
    };
};


function Cell(x, y, value) {
    this.x = x;
    this.y = y;
    this.value = value;
}


function Sheet() {
    this.cells = null;
    this.height = null;
    this.width = null;
    this.x = null;
    this.y = null;
    this.selected = null;
}


Sheet.prototype.moveSelection = function(direction, moveType) {
    let h = this.x;
    let v = this.y;

    let incrementX = 0;
    let incrementY = 0;
    if (direction === 'ArrowUp')
        incrementY = -1;
    else if (direction === 'ArrowDown')
        incrementY = 1;
    else if (direction === 'ArrowLeft')
        incrementX = -1;
    else if (direction === 'ArrowRight')
        incrementX = 1;
    h += incrementX;
    v += incrementY;

    let startIsFilled = (this.selected.value !== ' ');
    let lastCell = this.selected;
    let nextCell = 0 <= v && v < this.height && 0 <= h && h < this.width && new Cell(h, v, this.cells[v][h]);
    let nextIsFilled = (nextCell && nextCell.value !== ' ');
    let stopCondition = !(startIsFilled && nextIsFilled);

    let numberOfSteps = (moveType === 'skip' ? -1 : 1);
    let stepsTaken = 0;

    while (nextCell) {
        // check steps within the loop in case we can't take a step w/o being OOB
        stepsTaken += 1;
        if (stepsTaken === numberOfSteps)
            break;
        
        nextIsFilled = (nextCell.value !== ' ');
        if (nextIsFilled === stopCondition) {
            if (!stopCondition) // if stoppiing at end of filled row, clear nextCell so that lastCell is selected
                nextCell = null;
            break;
        }

        h += incrementX;
        v += incrementY;
        lastCell = nextCell;
        nextCell = 0 <= v && v < this.height && 0 <= h && h < this.width && new Cell(h, v, this.cells[v][h]);
    }
    this.selectCell(nextCell || lastCell); // use the last if the next is undefined
};


Sheet.prototype.selectCell = function(cell) {
    this.x = cell.x;
    this.y = cell.y;
    this.selected = cell;
};


Sheet.prototype.selectXY = function(x, y) {
    if (this.x == x && this.y == y)
        return;
    this.x = x;
    this.y = y;
    this.selected = new Point(x, y, this.cells[y][x]);
};


Sheet.prototype.loadLevel = function(level) {
    this.cells = level;
    this.height = level.length;
    this.width = level.reduce((lastMax, row) => Math.max(lastMax, row.length), 0);
};


Sheet.prototype.updateSelectedCellValue = function(str) {
    this.selected.value = str;
    this.cells[this.y][this.x] = str;
};


//--------- no globals
function Point(x, y) {
    this.x = x;
    this.y = y;
}


function View(sheet, tblContainer) {
    this.cells = null;
    this.selected = null;
    this.rowLabels = null;
    this.colLabels = null;
    this.corner = null;

    this.tblContainer = tblContainer;
    this.tbl = tblContainer.children[0];
    this.sheet = sheet;
    this.rowHeights = new Array(sheet.height + 1).fill('1.5em');
    this.colWidths = new Array(sheet.width + 1).fill('2.5em');

}


View.prototype.makeGrid = function() {
    this.cells = [];
    this.colLabels = [];
    this.rowLabels = [];
    
    // make header
    let header = document.createElement('thead');
    this.tbl.appendChild(header);
    let rowEl = document.createElement('tr');

    // top corner
    let cellEl = getCell('th', 0, 0, this.rowHeights[0], this.colWidths[0], 'corner', ' ');
    rowEl.appendChild(cellEl);
    this.corner = cellEl

    // rest of header row
    for (let h = 1; h < this.sheet.width + 1; h++) {
        cellEl = getCell('th', h, 0, this.rowHeights[0], this.colWidths[h], 'colLabel', getLetterCode(h));
        rowEl.appendChild(cellEl);
        this.colLabels.push(cellEl);
    }
    header.appendChild(rowEl);
    
    // data rows
    let body = document.createElement('tbody');
    this.tbl.appendChild(body)
    for (let i = 1, v = 0; i < this.sheet.height + 1; i++, v++) {
        rowEl = document.createElement('tr');
        
        // make row header
        cellEl = getCell('th', 0, i, this.rowHeights[i], this.colWidths[0], 'rowLabel', i);
        rowEl.appendChild(cellEl);
        this.rowLabels.push(cellEl);

        // fill row
        let row = []
        for (let j = 1, h = 0; j < this.sheet.width + 1; j++, h++) {
            cellEl = getCell('td', h, v, this.rowHeights[i], this.colWidths[j], 'cell', '');
            cellEl.innerText = this.sheet.cells[v][h];
            if (cellEl.innerText == 'X')
                cellEl.classList.add('goal');
            rowEl.appendChild(cellEl);
            row.push(cellEl);
        }

        body.appendChild(rowEl);
        this.cells.push(row);
    }        

    // functions used above
    function getCell(type, h, v, height, width, cssClass, text) {
        let cellEl = document.createElement(type);
        cellEl.style.minheight = height;
        cellEl.style.minwidth = width;
        cellEl.id = h + ',' + v
        cellEl.classList.add(cssClass);
        cellEl.innerText = text;
        return cellEl;
    }

    function getLetterCode(num) {
        let code = [];
        let remaining = num;
        while (remaining > 0) {
            let nextChar = ((remaining - 1) % 26) + 1;
            remaining = (remaining - nextChar) / 26;
            code.push(String.fromCharCode(64 + nextChar));
        }
        code.reverse();
        return code.join('');
    }
};


View.prototype.paint = function() {
    let cell = this.cells[this.sheet.y][this.sheet.x];
    if (cell === this.selected)
        return;
    else if (this.selected) {
        this.selected.classList.remove('selected');
        const priorCoordinates = this.selected.id.split(',')
        const priorx = parseInt(priorCoordinates[0]);
        const priory = parseInt(priorCoordinates[1]);

        this.rowLabels[priory].classList.remove('selected');
        this.colLabels[priorx].classList.remove('selected');
    }
    cell.classList.add('selected');
    this.selected = cell;
    coordinates = cell.id.split(',');
    const x = parseInt(coordinates[0]);
    const y = parseInt(coordinates[1]);
    this.rowLabels[y].classList.add('selected')
    this.colLabels[x].classList.add('selected')
    scrollSelection(cell, this.tblContainer, this.rowLabels, this.colLabels);
    if (this.selected.classList.contains('goal'))
        alert('you win!');



    function scrollSelection(cell, container, rowLabels, colLabels) {
        labelHeight = colLabels[0].clientHeight;
        if (container.scrollTop > cell.offsetTop - labelHeight)
            container.scrollTop = cell.offsetTop - labelHeight;
        else if (container.scrollTop + container.clientHeight < cell.offsetTop + cell.clientHeight)
            container.scrollTop = cell.offsetTop + cell.clientHeight - container.clientHeight;
        
        labelWidth = rowLabels[0].clientWidth;
        if (container.scrollLeft > cell.offsetLeft - labelWidth)
            container.scrollLeft = cell.offsetLeft - labelWidth;
        else if (container.scrollLeft + container.clientWidth < cell.offsetLeft + cell.clientWidth)
            container.scrollLeft = cell.offsetLeft + cell.clientWidth - container.clientWidth;
    }
    };


View.prototype.translateTarget = function(target) {
    coords = target.id.split(',');
    return new Point(parseInt(coords[0]), parseInt(coords[1]));
};


View.prototype.updateCellValue = function(str) {
    this.selected.innerText = str;
};

const sheetGame = new Game();






</script>
</html>